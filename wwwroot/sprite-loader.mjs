/**
 * Sprite Loader - Dynamically loads and injects SVG sprites into the DOM
 * Uses sprite-manifest.json generated by SvgSpriteWebpackPlugin
 */
(function () {
  "use strict";

  // Function to load sprite manifest
  async function loadSpriteManifest() {
    try {
      const response = await fetch("build/sprite-manifest.json");
      if (!response.ok) {
        throw new Error("Failed to load sprite manifest: " + response.status);
      }
      const manifest = await response.json();
      return manifest.sprites || [];
    } catch (error) {
      throw new Error("Invalid sprite manifest: " + error.message);
    }
  }

  // Function to load and inject a single sprite
  async function loadSprite(spriteUrl) {
    const response = await fetch(spriteUrl);
    if (!response.ok) {
      throw new Error(
        "Failed to load sprite: " + spriteUrl + " (" + response.status + ")"
      );
    }

    const svgContent = await response.text();

    const existingContainer = document.getElementById("svg-sprites");
    const spriteContainer = document.createElement("div");
    spriteContainer.innerHTML = svgContent;

    existingContainer.appendChild(spriteContainer.firstChild);

    console.log("SVG sprite loaded:", spriteUrl);
  }

  // Function to load all sprites
  async function loadAllSprites(spritePaths) {
    const promises = spritePaths.map(function (spritePath) {
      return loadSprite("build/" + spritePath);
    });

    return Promise.all(promises);
  }

  // Main function to initialize sprite loading
  async function initSpriteLoader() {
    // Only load if document is ready
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", initSpriteLoader);
      return;
    }

    try {
      const spritePaths = await loadSpriteManifest();
      await loadAllSprites(spritePaths);
    } catch (error) {
      console.warn("Sprite loader failed:", error.message);
    }
  }

  // Start the process
  initSpriteLoader();
})();
